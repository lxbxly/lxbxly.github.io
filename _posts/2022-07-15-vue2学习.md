[TOC]
#开始
##webpack
> 实际开发中不需要自己配置webpack
<link rel="stylesheet" href="//unpkg.com/layui@2.6.8/dist/css/layui.css">



**概念**：webpack 是前端项目工程化的具体解决方案。
**安装**：npm i webpack@5.42.1 webpack-cli -D
- -S是--save的简写
- -D是--save-dev的简写

**配置**
1. 项目更目录下新建webpack.config.js文件：
```js
//使用nodejs导出一个webpack配置对象
module.exports={
    mode:'development' //production
}
```
1. package.json中添加
```js
"scripts": {
    "dev":"webpack"
  }
```
1. 运行配置包：npm run dev -->生城dist文件
1. index中引入 dist下的的main.js

**自定义打包入口和出口**

- 在webpack.config.js配置文件中，通过**entry、output**指定需要打包的文件：

```js
const path=require('path')

//使用nodejs导出一个webpack配置对象
module.exports={
    //development ： 开发过程中，体积大，打包快 和 production ：上线阶段，体积小
    mode:'development' ,
    // entry:'指定要处理那个文件'
    entry:path.join(__dirname,'/src/index.js'),
    output:{
        //存放目录
        path:path.join(__dirname,'dist'),
        //生成的文件名
        filename:'bundle.js'
    }
}
```
##webpack插件
**自动打包**

> 包 ： webpack-dev-server : 类似nodemon

- 安装：npm i webpack-dev-server@3.11.2 -D
- 配置 :
```js
"scripts": {
    "dev": "webpack serve"
  },
```
- 加载和应用内存中的bundle.js
```js
<script src="/bundle.js"></script>
```
```js
i ｢wds｣: Project is running at http://localhost:8080/
i ｢wds｣: webpack output is served from /
i ｢wds｣: Content not from webpack is served from D:\LXB\学习\web\vue\vue-02\change-rows-color       
i ｢wdm｣: asset bundle.js 650 KiB [emitted] (name: main)
```

**复制指定页面到指定目录**
> html-webpack-plugin ：复制指定页面到更目录,注入到主页

- 安装: npm i html-webpack-plugin -D
- 配置：

```javascript
const path=require('path')

//1.导入 HTML 插件，得到一个构造函数
const HtmlPlugin=require('html-webpack-plugin')
// 2.new 构造函数，创建插件的实例对象
const htmlPlugin=new HtmlPlugin({
    //指定复制哪个页面
    template:'./src/index.html',
    //指定复制出来的文件名和存放路径
    filename:'./index.html'
})


//使用nodejs导出一个webpack配置对象
module.exports={
    //development ： 开发过程中，体积大，打包快 和 production ：上线阶段，体积小
    mode:'development' ,
    // entry:'指定要处理那个文件'
    entry:path.join(__dirname,'/src/index.js'),
    //指定的文件存放在哪
    output:{
        //存放目录
        path:path.join(__dirname,'dist'),
        //生成的文件名
        filename:'bundle.js'
    },
    //插件的数组，将来wenpack 在运行时，会加载调用这些插件
    plugins:[htmlPlugin]
}
```

**配置访问路径**
- devServer：配置访问路径
```js
    //配置访问路径
    devServer:{
        //首次打包成功后自动打开浏览器
        open:true,
        //自定义端口号
        port:80,
        //指定运行地址
        host:'127.0.0.1'
    }
```

**loader处理css文件**

- 打包其他文件格式css
`import './css/index.css'`
- 安装：npm i style-loader -D
- 配置： webpack.config.js的module->rules数组中，添加loader规则如下：
```js
module:{
        rules:[
            //定义不同模块对呀的 loader
            {test:/\.css$/,use:['style-loader','css-loader']}
        ]
    }
```
- loader从后往前进行运行

**loader处理less(css)文件**
- 安装 ： npm i less-loader less -D
- 配置 ： rules下添加：
```js
module:{
        rules:[
            {test:/\.css$/,use:['style-loader','css-loader']},
            {test:/\.less$/,use:['style-loader','css-loader','less-loader']}
        ]
    }
```

**loader处理图片**
> [ 小图片转base64，防止网页发起不必要的请求····`src='./',src='base64'`](https://c.runoob.com/front-end/59/ "> 图片转base64，防止网页发起不必要的请求····src='',src='base64'")

- 安装 ： url-loader file-loader -D
- 配置 : 
```js
module: {
        rules: [
            { test: /\.css$/, use: ['style-loader', 'css-loader'] },
            { test: /\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] },
            { test: /\.jpg|png|gif$/, use: 'url-loader' }//调用一个，不需数组
        ]
    }
```
- 限制
```js
{ test: /\.jpg|png|gif$/, use: 'url-loader?limit=222229' }//调用一个，不需数组
```
> 当图片大于limit时不转为base64.

**对webpack处理不了的高阶语法**

> babel-loader

- 安装 ：npm i babel-loader @babel/core @babel/plugin-proposal-decorators -D
- 配置 ：rules中添加规则：
```js
//只需转换自己的js。一定要排除node_modules中的js
            {test:/\.js$/,use:'babel-loader',exclude:/node_modules/}
```
- 配置插件的插件：
 - 配置：根目录新建 babel.config.js 写入：
```js
module.exports={
    plugins:[['@babel/plugin-proposal-decorators',{legacy:true}]]
}
```

##webpack打包发布
- 配置 ：在 package.json 文件的 scripts 节点下，新增 bulid 命令如下：
```js
  "scripts": {
    "dev": "webpack serve",//开发环境中，运行 dev 命令
    "build":"webpack --mode production" //项目发布时 ，运行 build 命令
  },
```
> --mode production 优先级高于 配置文件 webpack.config.js 中的 mode 的优先级。

- 由于发布的问价较凌乱，需要文件统一
<center>![](https://www.showdoc.com.cn/server/api/attachment/visitFile?sign=57bc407b4ad87d07d7c12cf43431dd4a&file=file.png)
</center>
1. 整理js文件：

```js
	 output:{
			//存放目录
			path:path.join(__dirname,'dist'),
			//生成的文件名
			filename:'js/bundle.js'
		},
```

2. 整理img文件

> 图片小于 limit 上限会直接转成 base64 字符串，不会生成 images 文件夹

```js
	//在配置url-loader，多个参数用 & 进行分隔
				{test:/\.jpg|png|gif$/,use:['url-loader?limit=222229&outputPath=images']}
```

<center>![](https://www.showdoc.com.cn/server/api/attachment/visitFile?sign=1779bde5a392f9866640ba76d91f772e&file=file.png)</center>

**自动清除dist包文件夹**
> clean-webpack-plugin

- 安装： npm i clean-webpack-plugin -D
- 配置： [npm 文档](https://www.npmjs.com/package/clean-webpack-plugin "npm 文档")

```js
const { CleanWebpackPlugin } = require('clean-webpack-plugin');

const webpackConfig = {
    plugins: [
        /**
         * All files inside webpack's output.path directory will be removed once, but the
         * directory itself will not be. If using webpack 4+'s default configuration,
         * everything under <PROJECT_DIR>/dist/ will be removed.
         * Use cleanOnceBeforeBuildPatterns to override this behavior.
         *
         * During rebuilds, all webpack assets that are not used anymore
         * will be removed automatically.
         *
         * See `Options and Defaults` for information
         */
        new CleanWebpackPlugin(),
    ],
};

module.exports = webpackConfig;
```
> `{ CleanWebpackPlugin } = require('clean-webpack-plugin');`
- {} 解构赋值
{变量}={变量：function(){}}:将函数中的属性复制到变量里，属性名与变量名必须一致。

##webpack Source Map
> 浏览器后端正确展示错误信息的具体位置，而不是磁盘中打包生成的 js 中的的错误位置

- 解决默认 Source Map 的问题
- 在 webpack.config.js 中添加如下配置
```js
    mode: 'development',
    //解决Source Map
    devtool:'eval-source-map',
    // entry:'指定要处理那个文件'
    entry: path.join(__dirname, '/src/index.js')
```
>   devtool:'eval-source-map' 不配置此项，防止代码泄露

- 只定位行数，不暴露源码(实际发布设置，或者不配置 devtool )
> devtool:'nosources-source-map',

<center>![](https://www.showdoc.com.cn/server/api/attachment/visitFile?sign=37f4910743f0fa53ed8488ae8abbfd4f&file=file.png)</center>

##@注
> `import msg from '../../msg'`

- 推荐使用 @ 表示 src 源代码目录，从外往里查找；不要使用 ../ 从里往外查找

> `@/msg`

- 配置： 

> `resolve:{
      alias:{
          '@':path.join(__dirname,'./src/')
      }
  }`

- 例：
```js
module.exports = {
    //development ： 开发过程中，体积大，打包快 和 production ：上线阶段，体积小
    mode: 'development',
    //解决Source Map
    devtool:'nosources-source-map',
    // entry:'指定要处理那个文件'
    entry: path.join(__dirname, '/src/index.js'),
    //指定的文件存放在哪
    output: {
        //存放目录
        path: path.join(__dirname, 'dist'),
        //生成的文件名
        filename: 'js/bundle.js'
    },
    //插件的数组，将来wenpack 在运行时，会加载调用这些插件
    plugins: [htmlPlugin,new CleanWebpackPlugin],
    //配置访问路径
    devServer: {
        //首次打包成功后自动打开浏览器
        open: true,
        //自定义端口号
        port: 80,
        //指定运行地址
        host: '127.0.0.1'
    },
    module: {
        rules: [
            //定义不同模块对应的 loader
            { test: /\.css$/, use: ['style-loader', 'css-loader'] },
            //在配置url-loader，多个参数用 & 进行分隔
            { test: /\.jpg|png|gif$/, use: 'url-loader?limit=1000&outputPath=images' },
            { test: /\.js$/, use: ['babel-loader'], exclude: /node_modules/ }
        ]
    },
    resolve:{
        alias:{
            '@':path.join(__dirname,'./src/')
        }
    }
}
```

#vue调试工具
> Vue.js.devtools

<center>![](https://www.showdoc.com.cn/server/api/attachment/visitFile?sign=ecb48a3b0126511dd1ed249547f0c361&file=file.png)</center>

#vue标签属性绑定
> [笔记](https://www.bilibili.com/read/cv14309317/ "笔记")

- 特性：俩特性，数据驱动视图(单项数据绑定)，双向数据绑定。

##指令
```
const vm = new Vue({
            el: '#app',
            data: {
                name: 'app',
                sex: '女',
                info: '<h4 style="color:red;font-size:10px">欢迎</h4>',
                tips:'请输入东西',
            }
        })
```

**1.  v-text**

```js
<p v-text="name"></p>
```
**2.v-html**

```html
<div v-html="info"></div>
```
**3.{ { } }**

```
 <p>{{sex}}</p>
```
- 只能用在内容中，不能用在属性中
- 可以写一些js方法：`{{ok?'yes':'no'}}`

**4.v-bind: / :**

```
<input type="text" :placeholder="tips">
<img v-bind:src="photo" alt="">
```
> 可以写一些js方法：`        <div :title="'box'+index"></div>`

<center>![](https://www.showdoc.com.cn/server/api/attachment/visitFile?sign=90ab79a5b65b46aa19339de9e9cbf746&file=file.png)</center>

**5.v-on:**

```
<button v-on:click="add(2)">+1</button>
```
```
 const vm = new Vue({
            el: '#app',
            data: {},
            //定义事件处理函数
            methods:{
                 add: function (n) {
                    vm.count+=n
                },
                sub() {
                    this.count--
                }
            }
        })
```
> 简写 @click
`<button @click="sub(2)">+1</button>`

**6.鼠标事件**

```
<button @click="addstyle">mouseevent</button>

 const vm = new Vue({
            el: '#app',
            data: {},
            //定义事件处理函数
            methods: {
                add: function () {
                    vm.count++
                },
                sub(n) {
                    this.count+=n
                },
                addstyle(e){
                    console.log(e);
                }
            }
        })
```
- ` @click='fun'`:不写括号，不传参，methods中的 fun(e){} 为鼠标事件

> vue 提供的鼠标事件 $event

```
<button @click="addstyle(1,$event)">mouseevent</button>
```
```
addstyle(n,e){
                    console.log(e);
                }
```

**7.事件修饰符**

> `e.preventDefault()` 	：dom提供的阻止默认行为
`@click.prevent='fun'`  : vue 提供的阻止默认行为

<center>![](https://www.showdoc.com.cn/server/api/attachment/visitFile?sign=996b6b39d5c3dd04ad6455d23664141d&file=file.png)</center>

**8.按键修饰符**

```
<input type="text" @keyup.esc="clearInput" @keyup.enter="commitAjax">
```
```
clearInput(e){
   e.target.value=''
},
commitAjax(){
   console.log('触发');
}
```

**9.v-model**
> 双向绑定指令，value <= v-model 

`<input type="text" v-model="name">`
- input 输入框
- textarea
- select

```
<select name="" id="" v-model="city">
            <option value="">--请选择城市--</option>
            <option value="0">北京</option>
            <option value="1">上海</option>
            <option value="2">广州</option>
        </select>
```
```
 data: {
       city:''
},
```
**10.v-model指令的修饰符**

> 字符串拼接

```
<input type="text" v-model="n1">+<input type="text" v-model="n2">=<p>{{n1+n2}}</p>
```
```
data: {
    n1:1,
    n2:2
 },
```
> 加法 `v-model.number=""`

```
<input type="text" v-model.number="n1">+<input type="text" v-model.number="n2">=<p>{{n1+n2}}</p>
```
> `v-model.trim=''` 去除空格占位符

```
<input type="text" name="" id="" v-model.trim="name"><button @click="bname"></button>
```
```
methods: {
  bname(){
   console.log(`姓名是:"${this.name}"`);
 }
}
```

> `v-model.lazy=''`失去焦点后同步

```
<input type="text" name="" id="" v-model.lazy="name">
```
**11.条件渲染指令**
> v-if 、v-show

- v-if : 动态创建或移除元素，实现元素的显示和隐藏(特殊情况下展示时)
- v-show : 操作 `display:none` 实现元素的显示和隐藏(频繁的隐藏和显示时)

***实际开发中不用考虑性能问题，直接使用 v-if （除非面试！）***

```
<p v-if="flag"></p>
<p v-show="flag"></p>
```
> v-else-if

```
<div v-if="type==='A'">优秀</div>
<div v-else-if="type==='B'">良好</div>
<div v-else-if="type==='C'">合格</div>
<div v-else="type==='D'">差</div>
```
```
data: {
 type:'A'
}
```
**12.列表渲染指令**
> [Bootstrap 快速开发 Web 应用程序和网站的前端框架](https://www.runoob.com/bootstrap/bootstrap-intro.html "Bootstrap 快速开发 Web 应用程序和网站的前端框架")

- **v-for **

```
<table class="table table-bordered table-hover table-striped">
            <thead>
                <th>索引</th>
                <th>id</th>
                <th>姓名</th>
            </thead>
            <tbody>
				 <!-- 官方建议： 用到 v-for ，一定要绑定一个 :key 属性 ，id作为 key 的值 -->
                <!-- key 的值 只能是 ：字符串或数字类型 key 的值不能重复-->
                <tr v-for="(item,index) in list" :key="item.id" :title="item.name">
                    <td>{{index}}</td>
                    <td>{{item.id}}</td>
                    <td>{{item.name}}</td>
                </tr>
            </tbody>
        </table>
```
```
data: {
                list:[
                    {id:1,name:'张三'},
                    {id:2,name:'里斯'},
                    {id:3,name:'王五'}
                ]
            },
```
<center>![](https://www.showdoc.com.cn/server/api/attachment/visitFile?sign=4cd6f39167c5c2aa833f5d50c4521c8a&file=file.png)</center>

#vue基础入门
##过滤器
>Filters函数(私有)，可用在以下两个地方：

**1. 私有过滤器**

- 插值表达式
- v-bind 属性绑定

```
<p>{{message| capi}}</p>
```
```
//过滤器函数
filters:{
   //val : {{index|capi}} 中的 index
	capi(val){
    //👍：过滤器中，一定要有一个返回值
    return val[0].toUpperCase() + val.substr(1) // val.charAt(0).toUpperCase+val.slice(1)
 }
}
```

**2 . 全局过滤器**
```
<p>{{message| capi}}</p>
<p>{{message| capi}}</p>
```
```
 Vue.filter('capi', (str) => {
        return val[0].toUpperCase() + val.substr(1) // val.charAt(0).toUpperCase+val.slice(1)
})
```
> **如果全局过滤器和私有过滤器冲突，按照就近原则调用私有过滤器。**

**3.连续调用多个过滤器**
`<p>{{message| capi|x|Y}}</p>`输出 Y 的值
- 传参
```
<p>{{message| filterA(arg1,arg2)}}</p>
```
```
Vue.filter('filterA', (str,arg1,arg2) => {
            return val[0].toUpperCase() + val.substr(1) // val.charAt(0).toUpperCase+val.slice(1)
        })
```

##侦听器
**1.语法**
> 函数格式的侦听器，检测值的变化（如：来发送ajax请求）

- 无法在刚进入页面时，自动触发。
- 如果侦听的是一个对象，如果对象中的属性发生了变化，不会触发侦听。

	
```
<input type="text" v-model="username">
```
```
const vm = new Vue({
            el:'#app',
            data:{
                username:''
            },
            methods:{},//click方法
            filters:{},//过滤器
            watch:{
                // 监听username
                //新值在前，旧值在后
                username(newVal, oldVal) {
                    if(newVal==='') return
                    console.log('username在变化', newVal, oldVal);
                    $.get('https://escook.cn/api/finduser/' + newVal,(res)=>{
                        console.log(res);
                    })
                }
               }
           }
        })
```
**2.页面加载就执行**
> 对象格式的侦听器

- immediate 让侦听自动触发
- 对象中的属性发生了变化，触发侦听（**深度侦听**）

```
watch: {
	username:{
		handler(newVal, oldVal){
			console.log('username在变化', newVal, oldVal);
	},
    immediate:true //false默认值,页面加载触发
	}
 }
```
**3.深度侦听**
```
info:{
	handler(newVal){
		console.log(newVal);
	},
	//开启深度监听
 	deep:true
}
```
- 如果要侦听的是对象的子属性的变化，则必须包裹一层单引号

```
//如果要侦听的是对象的子属性的变化，则必须包裹一层单引号

                'info.username':{
                    handler(newVal){
                        console.log(newVal);
                    }
                }
```

##计算属性
> 通过一系列运算后得到的**属性值**

```
<body>
    <div id="app">
        R:<input type="text" v-model="r"><br>
        G:<input type="text" v-model="g"><br>
        B:<input type="text" v-model="b">
        <br>
        <hr>
        <!-- :style 代表动态绑定一个样式对象，它的值是一个{ }样式对象 -->
        <!-- 当前的杨是对象中，只包含一个 backgroundColor 背景属性 -->
        <div class="box" :style="{backgroundColor: `rgb(${r},${g},${b})`}">
            {{`rgb(${r},${g},${b})`}}
        </div>
        <button @click="show">查看</button>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
    <script src="https://unpkg.com/dayjs@1.8.21/dayjs.min.js"></script>
    <script>
        const vm = new Vue({
            el: '#app',
            data: {
                r: 0,
                g: 0,
                b: 0
            },
            methods: {
                show(){
                    console.log(`rgb(${this.r},${this.g},${this.b})`);
                }
            },
            filters: {},//过滤器
            watch: {}//侦听器
        })
    </script>
</body>
```
- 手动拼接 rgb 复用性很低，需要***计算属性***

> computed:{}

- 在 template 模板中可以使用
- 在 methods 方法中。也可以使用 - this.计算属性的名字
```
<body>
    <div id="app">
        R:<input type="text" v-model="r"><br>
        G:<input type="text" v-model="g"><br>
        B:<input type="text" v-model="b">
        <br>
        <hr>
        <!-- :style 代表动态绑定一个样式对象，它的值是一个{ }样式对象 -->
        <!-- 当前的杨是对象中，只包含一个 backgroundColor 背景属性 -->
        <div class="box" :style="{backgroundColor: rgb}">
            {{rgb}}
        </div>
        <button @click="show">查看</button>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
    <script src="https://unpkg.com/dayjs@1.8.21/dayjs.min.js"></script>
    <script>
        const vm = new Vue({
            el: '#app',
            data: {
                r: 0,
                g: 0,
                b: 0
            },
            methods: {
                show(){
                    console.log(`rgb(${this.r},${this.g},${this.b})`);
                }
            },
            filters: {},//过滤器
            watch: {},//侦听器
            //计算属性定义到computed下，
            //属性计算定义时，要定义成‘方法格式’,用的时候当作属性用
            computed:{
                //返回rgb（x，x，x）
                rgb(){
                    return `rgb(${this.r},${this.g},${this.b})`
                }
            }
        })
    </script>
</body>
```
- 实现代码的复用
- 只要data中属性变了，它会自动重新求知

##axios
> axios 是一个专注于网络请求的库

```
async post() {
                    //如果调用某个方法的返回值是 Promise 实例，则前面可以加 await ~
                    //await 只能用在被 async ’修饰‘的方法中
                    const result = await axios({
                        method: 'POST',
                        url: 'http://www.liulongbin.top:3006/api/post',
                        data: {
                            name: 'zs',
                            age: 20
                        },
                        headers: {
                            a: 0
                        }
                    })
                    console.log(result);
                }
```
- 解构赋值：

```
const {data} = await axios({
                        method: 'POST',
                        url: 'http://www.liulongbin.top:3006/api/post',
                        data: {
                            name: 'zs',
                            age: 20
                        },
                        headers: {
                            a: 0
                        }
                    })
	console.log(data);
```
```
const { data: res } = await axios({
                        method: 'GET',
                        url: 'http://www.liulongbin.top:3006/api/getbooks',
                        params: {
                            id: 1
                        },
                        data: {


                        }
                    })
console.log(res);
```
**1.get请求**
```
axios.get('url',{
            params:{}
        })
```
**2.post请求**
```
axios.post('url',{
            name:'zs',
            gender:'男'
        })
```
##vue-cli

> vue.js开发的标准工具。简化webpack创建vue项目。

- [中文官网](https://cli.vuejs.org/zh/ "中文官网：")

- **安装**
> `npm i @vue/cli -g` 查看是否安装成功 `vue -V`
`vue create 项目名称`

![](https://www.showdoc.com.cn/server/api/attachment/visitFile?sign=41c6d582d61635a389dbbcbdb33e558b&file=file.png)

![](https://www.showdoc.com.cn/server/api/attachment/visitFile?sign=e34a139f3b6ba95bb9482c585e7a4d66&file=file.png)

![](https://www.showdoc.com.cn/server/api/attachment/visitFile?sign=8e93fd5455990b1319e35c5b0b66bc5e&file=file.png)

![](https://www.showdoc.com.cn/server/api/attachment/visitFile?sign=3315968f45c99c8c8ada0d281f10f090&file=file.png)

![](https://www.showdoc.com.cn/server/api/attachment/visitFile?sign=f8ab9b23724b1100b70290f2bd18ac1f&file=file.png)
> 解冻 ：ctrl + c

**1.项目构成**
- assets 文件夹，项目中用到的静态资源文件，如css样式表，图片资源
- components 文件夹：程序员封装的、可复用的组件，都要放到此目录下
- main.js 是项目的入口文件。整个项目运行，要先执行 main.js
- App.vue 是项目的主页面

> **vetur 插件，代码提示**

**2.vue项目的运行流程**
通过 main.js 把 App.vue 渲染到 public 的 index.html 中
```
new Vue({
  //把 render 函数指定的组件，渲染到 html 页面中
  render: h => h(App),
}).$mount('#app')
```
和以下一样：
```
new Vue({
	el:'#app'
  //把 render 函数指定的组件，渲染到 html 页面中
  render: h => h(App),
})
```
##vue组件

###1.构成
```
<template>
  <div id="app">
  </div>
</template>


<script>

</script>


<style lang="less">

</style>
```
###2. js结构
```
//固定写法，默认导出
export default {
  //注意： .vue 组件中的data不能指向对象
  //data必须是个函数
  data() {
    return {
      username: 'zs'
    }
  },
  methods:{
    changename(){
      // 在组件中。this 就是当前实例对象
      this.username='ls'
    }
  },
  watch:{},
  computed:{},//当前组件的计算属性
  filters:{}
}
</script>
```
###3. 组件使用的三个步骤
> 路径提示插件👉 Path Autocomplete

- 导入组件
```
import Left from '@/components/Left.vue'
import Right from '@/components/Right.vue'
```
- 注册组件
```
export default {
  components:{
    Left //全写  ： Left：Left
	  }
}
```
> 多组件注册→ `Left,Right`
- 使用组件
> 标签形式使用

	```
	<template>
	  <div id="app">
		<Left></Left>
	  </div>
	</template>
	```

> 在**组件A**的components节点下，注册了**组件F**，则组件F只能用在组件A中，不能用在**组件C**中。如需在C中使用F，则需重新在C中注册。

###4.注册全局组件
- main.js入口文件中，导入，通过Vue.component()方法，注册全局组件。
```
//导入需要被全局注册的组件
import Left from '@/components/Left.vue'
Vue.component('MyLeft',Left)
```

###5.组件中的props

> **是组件的自定义属性，提高组件的复用性(类似title等)**

- 定义自定义属性
```
 data() {
        return {
            count: 0
        }
    },
    //自定义属性，允许使用者通过自定义属性，为当前组件指定初始值
    props:['init']
```
- 自定义属性赋各自的值
```
<template>
    <div>
        <h1>Right</h1>
        <MyLeft init="1"></MyLeft>
    </div>
</template>
```
- 使用自定义属性
```
<p>count的值是：{{ init }}</p>
<button @click="init + +">+1</button>
```
效果：
<center>![](https://www.showdoc.com.cn/server/api/attachment/visitFile?sign=82fc5ea127db2e1f0de2a3f27a2c0c1b&file=file.png)</center>

> - 此处自定义属性的值为字符串，如需数值，则用 v-bind 进行绑定:
`<MyLeft :init="1"></MyLeft>`
> - js中的表达式只有一行可以写在标签行中:
`<button @click="count++">+1</button>`
> - props 中的值是‘只读的’，如果直接修改会报错
`<button @click="init + +">+1</button>`：👇：

<1> init 的转存：
```
export default {
    data() {
        return {
            count: this.init
        }
    },
    //自定义属性，允许使用者通过自定义属性，为当前组件指定初始值
    props:['init']
}
```
<2> 转存后使用：
```
<p>count的值是：{{ count }}</p>
<button @click="count++">+1</button>
```
**6.props的默认值default**

```
props:{
        init:{
            //如果外界使用Count组件时，没有赋初始值，则使用默认值default的值
            default:0
        }
    }
```
**7.props的type**
> 值类型需要绑定 v-bind

```
 props:{
        init:{
            //如果外界使用Count组件时，没有赋初始值，则使用默认值default的值
            default:0,
            type:Number//{Array,Number,Object}
        }
    }
```
```
<MyLeft :init='1'></MyLeft>
```
**8.props的required**
> 用到自定义组件就必须传此值。用于**校验自定义组件有没有传递此用户自定属性**。不传则报错。

```
props:{
        init:{
            //如果外界使用Count组件时，没有赋初始值，则使用默认值default的值
            default:0,
            type:Number,//{Array,Number,Object}
            required:true
        }
    }
```

**9.组件之间的样式冲突问题**

> 原理：使用属性选择器 [target]{} target：用户自定义属性

```
<div class="lefr-container" data-v-001>
      <h1 data-v-001>Left</h1>
      <MyLeft :init="2"></MyLeft>
  </div>
<style lang="less">
.lefr-container{
    min-height: 250px;
    flex: 1;
}
.lefr-container[data-v-001]{
    color: aqua;
}
```
- 实际开发中

> style 中添加 scoped，会自动生成自定义属性

```
<style lang="less" scoped>
.lefr-container{
    min-height: 250px;
    flex: 1;
}
.lefr-container{
    color: aqua;
}
</style>
```
- 通过父元素修改自定义组件中元素的属性(自动后代选择器)

```
/deep/ h5{
    color: pink;
}
```
**----需要修改其他官方(第三方)组件的样式时可使用----**

------------
> ***vue 组件库： [vant](https://vant-contrib.gitee.io/vant/#/zh-CN/ "vant") [element-ui](https://element.eleme.io/#/zh-CN "element-ui")***

------------

#生命周期和数据共享
##组件的生命周期

<center>![](https://www.showdoc.com.cn/server/api/attachment/visitFile?sign=aaafa8af7ce8fbe786368f854181323c&file=file.png)</center>

- 经量别在生命周期函数中使用 async 

###组件创建
-  new Vue()
-  beforeCreate()：props data methods 都不可用
-  ※ created()：👍 最早发送如 **ajax**。在此阶段调用数据库，并把数据转存到 data 供template使用。无法操作 dom 元素。 props data methods 都可用
- beforeMount()：dom渲染之前。
- ※ mounted()：👍组件第一次被渲染到浏览器，操作 DOM 的最早时机

###组件运行
- beforeUpdate() :修改数据触发
> 当数据变化之后，为了能够操作最新的 DOM 结构，必须把代码写道 updated 生命周期函数中

- ※ updated() 能够操作到最新的 DOM 元素

###组件销毁
- beforeDestory():组件还在正常工作
- destoryed()

##组件之间的数据共享
> npm i : 报错 `npm cache clear --force`

**1.父向子传递数据（用自定义属性）**

- props : [👆](#5.%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84props "👆")

**2.子组件向父组件共享数据**
> 子组件向父组件共享数据要使用**自定义事件**。

- 事件触发

```
<button @click="add">+1</button>
this.$emit('click',val)
```
```
//子页面
methods:{
        add(){
            this.count++,
            this.$emit('numchange',this.count)
        }
    }
//父页面
<myLeftcom @numchange="getnewCount"></myLeftcom> //@ === v-on:
methods:{
    getnewCount(val){
      console.log(val);
      this.userinfo.soncount=val
    }
```
**3.兄弟组件之间的数据共享**

vue2.x中，共享方案时 ***EventBus***
<center>![](https://www.showdoc.com.cn/server/api/attachment/visitFile?sign=db7859cfa1be349fadb76af64774661a&file=file.png)</center>
<center>![](https://www.showdoc.com.cn/server/api/attachment/visitFile?sign=7280893bfcf62b9c6b2b1551d3cac842&file=file.png)</center>

也可以用全局数据总线

```
new Vue({
  router,
  store,
  beforeCreate () {
    Vue.prototype.$bus = this
  },
  render: h => h(App)
}).$mount('#app')
===============
 this.$bus.$emit('clear')
 ==================
mounted () {
    this.$bus.$on('clear', () => {
      this.keyword = ''
    })
  }
```

> vuejs 版本查看 jsdelivr.com/package/npm

##ref引用
- 起名
```
<h1 ref="myh1">
      App 跟组件
    </h1>
 <Left ref="comLeft"></Left>
```
- 使用
```
methods: {
    print() {
      console.log(this);
      this.$refs.myh1.style.color='red'
    }
  }
resetcount(){
      console.log(this.$refs.comLeft.resetcount);
      this.$refs.comLeft.resetcount()
    }
```

> 当某些代码需要 DOM 元素渲染完成后执行，则使用 :** $nextTick(cd) cd : 执行的回调函数**。

```
inputVisableeable() {
      this.inputVisable = true
      // setInterval(()=>{this.$refs.iptref.focus()},1000)
      this.$nextTick(()=>{
        this.$refs.iptref.focus()
      })
    },
```
##购物车案例

git地址

> 组件的复用性

```
<Goods v-for="item in list" :key="item.id" :title="item.goods_name" :price="item.goods_price" :img="item.goods_img" :status="item.goods_state"></Goods>
```
#动态组件、插槽、自定义指令
##动态组件
- 实现动态组件渲染 ： <component> 组件，***专门实现动态组件的渲染***

```
<component is="Left"></component>
```
- 动态绑定

```
<component :is="comname"></component>
data() {
    return {
      inputVisable: false,
      comname:'Left'
    }
  }
```
- 切换时防止数据刷新(组件重新渲染创建)

 > keep-alive 标签 ：

```
      <keep-alive>
        <component :is="comname"></component>
      </keep-alive>
```
- keep-alive 生命周期

1.当组件被**缓存**时，会自动触发组件的 **deactivated** 生命周期函数

2.当组件被**激活**时，会自动触发组件的 **activated** 生命周期函数(当组件被第一次创建时也会触发【created，activated】，被激活时只触发【activated】)

- keep-alive 的 include (exclude) 属性

> 限制被缓存的组件

```
//指定哪些需要被缓存
<keep-alive include="Left">
        <component :is="comname"></component>
</keep-alive>
//指定哪些不需要被缓存（两个属性只能出现一个）
<keep-alive exclude="Right">
        <component :is="comname"></component>
</keep-alive>
```
```
//父组件
components: {
    //如果在声明组件的时候，如果没有为组件声明name名称，则为注册时的名称。
    Left, Right
  }
//子组件
export default {
  name:'MyRight',
}
```
```
<keep-alive exclude="MyRight">
        <component :is="comname"></component>
```
> 组件的‘注册名称’的主要应用场景：以标签的形式放在页面中进行渲染
> 组件的声明时的‘name’的主要应用场景是：用于keep-alive 实现缓存，以及在调试工具中看到组件名称。

##插槽

> **slot**

```
      <Left>
        <!-- 默认情况下，在使用组件的时候，提供的内容被放到组件中的名字为 default 
          的 solt 插槽中 -->
        <p>这是在Left中渲染的</p>
      </Left>
```
```
        <!-- vue官方规定每个 slot 有一个 name ，默认为default -->
        <slot name="default">这是 default 插槽的默认内容（~~***当用户没有指定时生效***~~）</slot>
```
###指定插槽

```
      <Left>
        <!--   1. 默认情况下，在使用组件的时候，提供的内容被放到组件中的名字为 default 
          的 solt 插槽中 -->
          <!-- 2. v-slot: 后面跟插槽名称 -->
          <!-- 3. v-slot: 指令不能用在元素身上，必须用在 template 标签上  -->
          <!-- 4. template 是一个虚拟标签，只起到包裹作用，不会渲染任何实质性的html元素 -->
		            <!-- 5. v-slot 的简写：# -->
          <template #default>
            <p>这是在Left中渲染的</p>
          </template>
          <template v-solt:default>
            <p>这是在Left中渲染的</p>
          </template>
      </Left>
```
###具名插槽
插槽具有名称，就叫具名插槽

```
<slot name="author">这是 author 插槽的默认内容（~~***当用户没有指定时生效***~~）</slot>
```
###作用域插槽

- 插槽中可以定义数据供父组件使用

```
//子组件
<slot name="container" msg="hello xly"></slot>
//父组件
<template #container="scope">
          <p>我的天空,穿越时空</p>
          {{scope}}
</template>
```
- slot的解构赋值

```
1.data(){
        return {
            userinfo:{
                name:'zs'
            }
        }
    }
2.<slot name="container" msg="hello lxb" :user="userinfo"></slot>
3.<template #container="{ user }">
          <p>我的天空,穿越时空</p>
          {{ user }}
        </template>
```
###自定义指令

**1.私有自定义指令**

```
- 基本用法
//自定义指令使用
<h1 v-color>App 跟组件</h1>
//指令定义、注册
directives:{
    // 定义名为 color 的自定义指令，指向一个配置对象
    color:{
      //当指令***第一次***被绑定到元素上时，会立即触发bind函数
      // 形参中的 el 表示当前指令绑定的 DOM 元素
      bind(el){
        el.style.color='red'
      }
    }
  }
```

- 其他用法

```
1.data() {
    return {
        color:'blue'
    }
  },
2.<h1 v-color="color">App 跟组件</h1> <h1 v-color="'red'">测试</h1>
3.directives:{
    // 定义名为 color 的自定义指令，指向一个配置对象
    color:{
      //当指令第一次被绑定到元素上时，会立即触发bind函数
      // 形参中的 el 表示当前指令绑定的 DOM 元素
      bind(el,binding){
        console.log(binding);
        el.style.color=binding.value
      }
    }
  }
```
- 在 DOM 更新时会触发 updata 函数
```
// 在 DOM 更新时会触发 updata 函数
      update(el,binding){
        console.log(binding);
        el.style.color=binding.value
      }
```
- 如果 bind 和 update 函数中的逻辑完全相同，则对象格式的自定义指令可以简写成函数格式：

```
directives:{
	color(el,binding){
		el.style.color=binding.value
	}
}
```
**2.全局自定义指令**

```
Vue.directive('color',{
  bind(el,binding){
    el.style.color=binding.value
  },
  update(el,binding){
    el.style.color=binding.value
  }
})
//简写
Vue.directive('color',(el,binding)=>{
  el.style.color=binding.value
})
```

 **3. ESLint(代码风格约束器)**

ESLint + Standard config
debugger:打断点
- [黑马头条-移动端](http://doc.toutiao.liulongbin.top/mds/1.init.html "黑马头条-移动端")
- 自动格式化符合标准的 ESLint 的插件

| 插件名称  | 配置  |
| ------------ | ------------ |
|  ESlint | ESLint 插件的配置|
    "editor.codeActionsOnSave": {
        "source.fixAll": true
    }

| 插件名称  | 配置  |
| ------------ | ------------ |
|  prettier | ESLint 插件的配置|

```
    "editor.codeActionsOnSave": {
        "source.fixAll": true
    },
    //prettier 插件配置
    "prettier.configPath":"C:\\Users\\17736\\.prettierrc",

    "eslint.alwaysShowStatus": true,"prettier.trailingComma":"none",
    "prettier.semi": false,
    // 每行文字个数超出此限制将会被迫换行"prettier.printWidth": 300,// 使用单引号替换双引号
    "prettier.singleQuote": true,
    "prettier.arrowParens": "avoid",
    // 设置.vue 文件中，HTML代码的格式化插件
    "vetur.format.defaultFormatter.html": "js-beautify-html","vetur.ignoreProjectWarning": true,
    "vetur.format.defaultFormatterOptions":{ 
        "prettier": {
    "trailingComma": "none",
    "semi": false,
    "singleQuote": true,
    "arrowParens": "avoid",
    "printWidth": 300
    },
    "js-beautify-html": {
    "wrap attributes": false}
    }
```
> .prettierrc文件

```
module.exports = {
  printWidth: 200, //行宽
  semi: true, //分号
  singleQuote: true, // 使用单引号
  useTabs: false, //使用 tab 缩进
  tabWidth: 2, //缩进
  trailingComma: 'es5', //后置逗号，多行对象、数组在最后一行增加逗号
  arrowParens: 'avoid', //箭头函数只有一个参数的时候可以忽略括号
  bracketSpacing: true, //括号内部不要出现空格
  proseWrap: 'preserve', //换行方式 默认值。因为使用了一些折行敏感型的渲染器（如GitHub comment）而按照markdown文本样式进行折行
  parser: 'babylon', //格式化的解析器，默认是babylon
  endOfLine: 'auto', // 结尾是 \n \r \n\r auto
  jsxSingleQuote: false, // 在jsx中使用单引号代替双引号
  jsxBracketSameLine: false, //在jsx中把'>' 是否单独放一行
  stylelintIntegration: false, //不让prettier使用stylelint的代码格式进行校验
  eslintIntegration: false, //不让prettier使用eslint的代码格式进行校验
  tslintIntegration: false, // 不让prettier使用tslint的代码格式进行校验
  disableLanguages: ['vue'], // 不格式化vue文件，vue文件的格式化单独设置
  htmlWhitespaceSensitivity: 'ignore',
  ignorePath: '.prettierignore', // 不使用prettier格式化的文件填写在项目的.prettierignore文件中
  requireConfig: false, // Require a 'prettierconfig' to format prettier
}
```
> 包冲突： `npm i axios -S --legacy-peer-deps`

- [配置 axios 项](https://blog.csdn.net/weixin_43790653/article/details/124158618 "配置 axios 项")

**1. 导入**
```
import axios from 'axios'
```
**2.给vue添加axios属性**
```
// 全局配置 axios 的请求路径
axios.defaults.baseURL = 'http://www.liulongbin.top:3006'
// 把 axios 挂接到 Vue.prototype 上，供每个 .vue 组件的实例直接使用
Vue.prototype.$http = axios
// 把axios挂接不方便服用
```
**3.axios的使用**
```
 methods: {
    async postInfo() {
      const { data: res } = this.$http.post('http://www.liulongbin.top:3006/api/post', { name: 'zs', age: 20 })
      console.log(res)
    }
  }
```
【缺点】：请求数据的代码复用性差，如果不同的组件需要请求同一份数据，每请求一次，就要写一次请求函数。

**- 封装axios模块**

**1.封装axios模块**

在和src目录同级的地方，新建一个utils文件夹，表示用到的工具，在里面新建一个request.js文件，这个就是封装axios的模块。谁需要用到这个根路径去请求数据，谁就导入这个模块。

**request.js文件的内容：**
```
// 导入axios
import axios from 'axios'

// 通过axios.create方法创建一个axios实例，用request接收
const request = axios.create({
  // 指定请求的根路径
  baseURL: 'http://www.liulongbin.top:3006'
})

export default request
```
**使用方法（以Left组件为例）：**

```
<script>
// 导入request模块
import request from '@/utils/request.js'

export default {
  data() {
    return {
      bookList: {}
    }
  },
  methods: {
    async getInfo() {
      // 假设需要传一个参数，这里的参数是假的，演示用
      const { data: res } = await request.get('/api/getbooks', {
        params: { id: 1 }
      })
      console.log(res)
      // 一般把请求回来的数据转存到data中
      this.bookList = res
    }
  }
}
</script>
```
> 【拓展】一个项目中可以封装多个axios模块，如果需要用到多个不同的请求根路径，那么每一个根路径封装一个对应的axios模块，然后各模块之间互不相同，互不影响。

但是这个时候还是没有解决代码复用性低的问题，请求函数会重复写。此时我们再把请求数据的代码封**装成一个API模块**。

**2.封装API模块**
在和src目录同级的地方，新建一个api文件夹，表示自己写的api，在里面新建一个bookAPI.js文件，这个就是封装的books的模块，关于book的所有API接口，都可以封装到这个模块。谁需要用到这个API接口，谁就导入这个模块。

**bookAPI.js文件的内容：**
```
// 导入request模块
import request from '@/utils/request.js'

// 向外按需导出一个接口函数
export const getBookListAPI = function() {
  // 记得一定要把请求到的promise对象return出去
  return request.get('/api/getbooks', {
    // 假设需要传一个参数，这里的参数是假的，演示用
    params: { id: 1 }
  })
}
```
```
<script>
// 按需导入bookAPI
import { getBookListAPI } from '@/api/bookAPI.js'

export default {
  data() {
    return {
      bookList: {}
    }
  },
  methods: {
    async getInfo() {
      // 调用getBookListAPI请求数据
      const { data: res } = await getBookListAPI()
      console.log(res)
      // 一般把请求回来的数据转存到data中
      this.bookList = res
    }
  }
}
</script>
```
这就实现了请求数据接口的封装，提高了代码的复用性。

#路由
##路由的概念与原理
SPA：单页面应用程序
url 的 # 叫：哈希地址（hash）→location.hash
前端实现路由的方式主要有两种：hash模式和history模式、前端路由的本质为url改变页面不刷新、达到视图数据改变的结果。

1.hash模式：
window对象的location属性值里的 hash属性可以拿到hash值：window.location.hash。
window对象的全局方法hashchange()可以监听到hash值得变化。
主要基于这个原理来实现hash模式的前端路由。

```
<template>
  <div class="app-container">
    <h1>App 根组件</h1>
    <ul>
      <li><a href="#/home">首页</a></li>
      <li><a href="#/movie">电影</a></li>
      <li><a href="#/about">关于</a></li>
    </ul>
    <hr>
    <div class="box">
      <component :is="comName"></component>
    </div>
  </div>
</template>


<script>
import Home from '@/components/com-Home.vue'
import Movie from '@/components/com-Movie.vue'
import About from '@/components/com-About.vue'
export default {
  data() {
    return {
      comName: 'Home'
    }
  },
  created() {
    // 只要当前的 app 组件一被创建，就立即监听window对象的 onhashchange 事件
    window.onhashchange = () => {
      console.log('监听到哈希地址的变化', location.hash)
      switch (location.hash) {
        case '#/home':
          this.comName = 'Home'	//用箭头函数时，this 代表外层vue实例对象
          break
        case '#/movie':
          this.comName = 'Movie'
          break
        case '#/about':
          this.comName = 'About'
          break
        default:
          break
      }
    }
  },
  components: {
    Home, Movie, About
  }
}
</script>


<style>

</style>

```
##vue-router 的基本使用

> [官方网址](https://router.vuejs.org/zh/ "官方网址")

###1. 安装配置
> 可通过vue-cli一步到位 或 vue add router

- 安装 ：`npm i vue-router`,报错 ：`npm i --legacy-peer-deps vue-router@3.5.2`
- 创建路由模块

```
// 1.导入 Vue 和 VueRouter 的包
import Vue from 'vue'
import VueRouter from 'vue-router'

// 2.调用  Vue.use() 封装为插件
Vue.use(VueRouter)

// 3.创建构造函数
const router = new VueRouter()
// 4.向外共享实例对象
export default router
```
- 配置路由

```
import Vue from 'vue'
import App from './App.vue'
import axios from 'axios'
// 1.导入路由对象
import router from '@/router/index'

new Vue({
  render: h => h(App),
  // 在 Vue 项目中，要把路由用起来，必须把路由对象，通过下面方式挂载
  // 2.router: router
  router
}).$mount('#app')
```
- 使用

```
<!-- 只要在项目中配置了 vue-router ，就可以使用 router-view 这个组件了 -->
    <!-- 他的作用很单纯 ，占位符 -->
    <router-view></router-view>
```
```
// 1.导入 Vue 和 VueRouter 的包
import Vue from 'vue'
import VueRouter from 'vue-router'

// 导入需要的组件
import Home from '@/components/com-Home.vue'
import Movie from '@/components/com-Movie.vue'
import About from '@/components/com-About.vue'

// 2.调用  Vue.use() 封装为插件
Vue.use(VueRouter)

// 3.创建构造函数
const router = new VueRouter({
  // routes 是个数组，作用：定义 "hash地址"与组件之间的关系
  routes: [
  	//路由规则
    { path: '/home', component: Home },//为了程序员方便 # 被省略
    { path: '/movie', component: Movie },
    { path: '/about', component: About }
  ]
})
// 4.向外共享实例对象
export default router
```

- router-link

> vue-router 提供的 a 链接

```
<!-- 当安装和配置了 vue-router 后 ，就可以用 router-link 来替换 a 链接了 -->
    <router-link to="/home">首页</router-link>
    <router-link to="/movie">电影</router-link>
    <router-link to="/about">关于</router-link>
```

### 2.路由重定向
> redirect 属性

```
{
    path: '/',
    redirect: '/home'
  },
  {
    path: '/home',
    name: 'home',
    component: HomeView
  },
```
### 3.嵌套路由
> 需要 childern 属性声明子路由规则：

```
  {
    path: '/about',
    name: 'about',
    component: () => import('@/views/AboutView.vue'),
	//子路由模块
	path 中为空为默认子路由
    children: [{
      path: 'my',
      name: 'my',
      component: () => import('@/components/My.vue')
    }, {
      path: 'money',
      name: 'money',
      component: () => import('@/components/Money.vue')
    }]
  }
```
重定向
```
  {
    path: '/about',
    name: 'about',
    component: () => import('@/views/AboutView.vue'),
	//方法1	
	redirect:'/about/my'
    children: [{
      path: '',//方法2
      name: 'my',
      component: () => import('@/components/My.vue')
    }, {
      path: 'money',
      name: 'money',
      component: () => import('@/components/Money.vue')
    },
	//方法3	
	{
      path: '',
      redirect: 'my'
    }]
  }
```
###动态路由匹配
由于路由规则的复用性很差。通过Hash地址中可变的部分定义为参数项。
用动态插值表达式给页面插入数据时，this可加可不加

```
<!-- 注意1：在 hash 地址中，/后面的参数项，叫做‘路径参数’ -->
        <!-- 在路由参数对象中，需要使用this.$route.params 来访问路径参数 :id -->
        <!-- 注意2： 在 hash 地址中，？后的参数项叫做查询参数 -->
        <!-- 在路由参数对象中，需要this.$route.query 来查询查询参数 ?name=zs age=20 -->
		 <!-- 注意3：在 this.$route 中。path :/movie/2  只是路径部分，fullpath :/movie/2?name=zs age=20 才是完整的地址 -->
        <router-link to="/movie/1">诺记</router-link>|
        <router-link to="/movie/2?name=zs age=20">雷神</router-link>|
        <router-link to="/movie/3">复联</router-link>
        <hr>
        <router-view></router-view>
```
```
{
    path: '/movie',
    name: 'movie',
    component: () => import('@/views/MovieView.vue'),
    redirect: '/movie/1',
    children: [{
      path: ':id',
      // 需求，在movie 中通过id的值展示对应电影
      component: () => import('@/Movie/1.vue'),
      // 可以为路由开启传参，动态传参
      props: true
    }]
  }
```
```
export default {
  props: ['id'],
  methods: {
    print () {
      console.log(this)
    }
  }
}
```
- this.$route 和 this.$router 的区别：
this.$route： 是路由的“参数对象”。
this.$router：是路由的“导航对象”。
##vue-router 的常见方法
> 1.声明式导航
- 普通网页中点击<a>链接，vue项目中点击<router-link>都属于声明式导航
> 2.编程式导航
- 如 location.href=''

###1.vue-router 中的编程式导航

**①** this.$router.push('hash地址')

- 跳转到指定 hash 地址，并增加一条历史记录。

**②** this.$router.replace('hash地址')
- 跳转到指定 hash 地址，并替换掉当前的历史记录。

**③** this.$router.go(数值n)
- 可以前进和后退（超过上限，则原地不动）
- 简化方法：<div style='background-color:pink;border:1px solid black;border-radius:5px'>**①** $router.back() <br> - 在历史记录中，后退到上一个页面 <br>**②** $router.forward() <br> - 在历史记录中，前进到下一个页面</div>
> 写到行内时：this 去掉,否则报错。

```
<button @click="gotoLK">push跳转到'洛基'页面</button>
    <button @click="gotoLK2">push跳转到'洛基'页面</button>
    <button @click="back">后退</button>
    <button @click="$router.back()">后退</button>
    <button @click="$router.forward()">前进</button>
	methods: {
    gotoLK() {
      // 通过编程式导航API，跳转到指定页面
      console.log(this)
      this.$router.push('/movie/1')
    },
    gotoLK2() {
      // 通过编程式导航API，跳转到指定页面
      this.$router.replace('/movie/1')
    },
    back() {
      this.$router.go(-1)
    }
  }
```
###2.导航守卫
> 控制路由的访问权限。

<center>![](https://www.showdoc.com.cn/server/api/attachment/visitFile?sign=eb25ec582a2061fe57e4e4285bdd5bf0&file=file.png)</center>

- 全局前置守卫

```
// 为router 实例对象，声明全局前置导航守卫
// 只要发生了路由的跳转，必然会触发beforEach 指定的fun回调函数
router.beforeEach(function(to, from, next) {
  // to:将要到达的路由对象
  console.log(to)
  // from:将要离开的路由信息对象
  console.log(from)
  // next函数表示放行的意思
  next()
})
```
- next函数的 3 重调用方式
<center>![](https://www.showdoc.com.cn/server/api/attachment/visitFile?sign=02790dc71b1b3575c47f6ace5f6f211e&file=file.png)</center>

> next():放行，如果不放行，需要跳转则next('hash')

##后台管理案例

**1. 用到的知识点**
- vue.config.js配置文件中：

```
const path = require('path')
const themesPath = path.join(__dirname, '/src/theme.less')
const { defineConfig } = require('@vue/cli-service')
module.exports = defineConfig({
  transpileDependencies: true,
  publicPath: './',
  css: {
    loaderOptions: {
      less: {
        // 若 less-loader 版本小于 6.0，请移除 lessOptions 这一级，直接配置选项。
        lessOptions: {
          modifyVars: {
            // 直接覆盖变量
            // 'nav-bar-background-color': 'red'// 要重启服务器太麻烦
            // // 或者可以通过 less 文件覆盖（文件路径为绝对路径）
            hack: `true; @import "${themesPath}";`
          }
        }
      }
    }
  }
})
```
- less文件中
@相当于var、count、let，是less专门用于定义变量的如：

```
// 在 theme.less 中，覆盖官方的less变量
@blue:#007bff;

@nav-bar-background-color: @blue;
@nav-bar-title-text-color:#FFF;
```

> 【注意】：① :id 只能放在路由规则里面，不能放到路径里面如：

```
{
        path: 'userinfo/:id',
        props: true,
        component: () => import('@/components/UserData/UserData.vue')
      }
```

- npm run build 打包生成的dist文件中含有.map文件，用于提示报错信息，但以及上线了，没必要，可以在配置文件vue.config.js中加入：

 `productionSourceMap: false`

##file协议运行

在vue.config.js 中配置：publicPath: './',
lodashjs：[鲁大师](https://www.lodashjs.com/ "鲁大师")


##其他知识点

- 关闭校验：vue配置文件中添加---lintOnSave:false
- 组件驼峰：组件名为 AbcDefg 可写为：<abc-defg/>
- Mockjs:拦截ajax请求，生成随机数据，前端模拟后端接口